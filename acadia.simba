program acadia;
{$I SRL-6/SRL.simba}

const
  ACADIA_LOGS_DTM := DTMFromString('mrAAAAHic42BgYGAFYkkglgBiOSDmAmI2BghggWJOKF8AiMWBWASI+aFqXcy1gCQTQ4CdEUOCtx1DcaQng5OpFoOblS5YnBBgJIBhAAAahgWP');
  ACADIA_TREE_DTM := DTMFromString('mggAAAHicY2NgYJBiZGCQA2IVIJYFYjEo1gbKqQGxDhDrA7EeEGsBcdkUE4aCSeYMFfOsGFJaTBiKptswlPUbM/AD5bBhRhwYAgCumgl2');

const
  INVENTION_BOX := intToBox(615, 568, 638, 591);
  BOGUS_POINT := Point(0, 0);

//Invention topleft 615, 568
//Invention bottomright 638, 591

function beginDisassembleLogs(): Boolean;
var
  slots: TIntegerArray;
  p: TPoint;
begin
  tabBackpack.open();

  slots := findItem(ACADIA_LOGS_DTM, tabBackpack.getSlotBoxes(), false);

  if High(slots) = -1 then
  begin
    result := false;
    exit();
  end;

  tabBackpack.mouseSlot(slots[0] + 1, MOUSE_MOVE);
  gaussBox(p, INVENTION_BOX);

  dragMouse(p);
  result := True;
end;

procedure disassembleLogs();
var
  tries: Integer;
  started: Boolean;
begin
  for tries := 0 to 2 do
  begin
    if(beginDisassembleLogs()) and (progressScreen.isOpen(1200)) then
      break;
  end;

  while(progressScreen.isOpen(600)) do
  begin
    if not(started) then
    begin
      started := True;
      mouseOffClient(OFF_CLIENT_RANDOM, Random(1800));
    end;
    wait(Random(12000));
  end;
end;

function shouldDisassembleLogs(): Boolean;
begin
  tabBackpack.open();
  result := tabBackpack.isFull();
end;

function findTreeInBox(box: TBox): TPoint;
var
  p: TPointArray;
begin
  if(findDTMs(ACADIA_TREE_DTM, p, box)) then
  begin
    writeLn('Found tree in box: ', box);
    result := MedianTPA(p);
  end
  else
  begin
    writeLn('Couldn''t find a tree in box: ', box);
    result := BOGUS_POINT;
  end;
end;

function findTree(): TPoint;
begin
  result := findTreeInBox(mainScreen.getBounds());
end;

function hoverTree(treePoint: TPoint): Boolean;
begin
  if(treePoint.equals(BOGUS_POINT)) then
  begin
    result := false;
    exit;
  end;

  writeln('Hovering over tree at: ', treePoint);
  mouse(treePoint, MOUSE_MOVE);
  result := isMouseOverText(['Acadia tree'], 1200);
end;

procedure chopTree(treePoint: TPoint);
var
  treeBox: TBox;
  center: TPoint;
begin
  writeln('Chopping tree at point: ', treePoint);

  if Random(100) < RandomRange(13,25) then
  begin
    missMouse(treePoint, true);
  end;
  writeln('Created treebox at: ', treeBox);

  mouse(treePoint, MOUSE_LEFT, MOUSE_HUMAN);

  while(isLoggedIn() and not shouldDisassembleLogs()) do
  begin
    center := mainScreen.getCenterPoint();
    treeBox.setBounds(center.X-20,center.Y-20,center.X+20,center.Y+20);

    treePoint := findTreeInBox(treeBox);
    if(treeBox.isPointInside(treePoint)) then
    begin
      mouseOffClient(OFF_CLIENT_RANDOM, random(1800));
      wait(random(3400));
    end
    else break;
  end;
end;

var
  failures: Integer;
  treePoint: TPoint;
begin
  clearDebug();
  setupSRL();

  while(isLoggedIn()) do
  begin
    if(shouldDisassembleLogs()) then
    begin
      writeLn('Inventory full - disassembling logs');
      disassembleLogs();
    end;

    for failures := 0 to 5 do
    begin
      treePoint := findTree();
      if(hoverTree(treePoint)) then
      begin
        chopTree(treePoint);
        break;
      end
      else
      begin
        writeln('Failed to hover over a tree -- waiting');
        wait(Random(3600))
      end;
    end;

    wait(random(3600));
  end;

  writeln('Script ended');
  writeln('We are logged in: ', isLoggedIn());
end.
